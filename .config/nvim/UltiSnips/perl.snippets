priority 50

### Assorted Boilerplate #######################################

snippet #! "shebang" bA
#!/usr/bin/env perl

$0
endsnippet

snippet use "use ..." b
use $1 ${3:qw($2)};
$0
endsnippet

snippet req "requires ..."

endsnippet

snippet sw "use strict; use warnings;" b
use strict;
use warnings;

$0
endsnippet

snippet sw5 "use v5.14; use warnings;" b
use v5.14;
use warnings;

$0
endsnippet

snippet s2 "use strictures 2" b
use strictures 2;
$0
endsnippet

snippet feat "use feature 'foo'" b
use feature '${1:say}';
$0
endsnippet

snippet const "use constant foo => bar" b
use constant $1 => $2;
endsnippet

snippet noex "no warnings 'experimental::foo'"
no warnings 'experimental::$1';
endsnippet

snippet pack "package Foo::Bar ..." b
package ${1:`!v expand('%:.:h:gs?/?::?')`}::${2:`!v expand('%:t:r')`};

$0

1;
endsnippet

snippet version "our $VERSION ..." b
our $VERSION = "${1:0.001}";
$VERSION = eval $VERSION;

$0
endsnippet

snippet exporter "use Exporter qw(import) ..." b
use Exporter qw(import);
our @EXPORT    = qw($2);
our @EXPORT_OK = qw($1);
our %EXPORT_TAGS = ($3);

$0
endsnippet

snippet exporter "use parent 'Exporter::Tiny'" b
use parent 'Exporter::Tiny';
our @EXPORT    = qw($2);
our @EXPORT_OK = qw($1);
our %EXPORT_TAGS = ($3);
endsnippet

snippet module "New Module boilerplate" b
package ${1:Foo::Bar};

use ${2:strict};
use warnings;

our $VERSION = "${3:0.001}";
$VERSION = eval $VERSION;

use Exporter qw(import);
our @EXPORT    = qw($5);
our @EXPORT_OK = qw($4);

$0

1;
endsnippet

### Branch Statements and Loops ################################

snippet if "if ..."
if ($1)
{
	${VISUAL}$0
}
endsnippet

snippet ifx "if (modifier)"
${1:${VISUAL/;//}} if $2;
endsnippet

snippet el "else ..."
else
{
	${VISUAL}$0
}
endsnippet

snippet eli "elsif ..."
elsif ($1)
{
	${VISUAL}$0
}
endsnippet

snippet ife "if .. else"
if ($1)
{
	${VISUAL}$2
}
else
{
	$3
}
endsnippet

snippet ifei "if .. elsif"
if ($1)
{
	${VISUAL}$2
}
elsif ($3)
{
	$4
}
endsnippet

snippet ifee "if..elsif..else"
if ($1)
{
	${VISUAL}$2
}
elsif ($3)
{
	$4
}
else
{
	$5
}
endsnippet

snippet unl "unless"
unless ($1)
{
	${VISUAL}$0
}
endsnippet

snippet unlx "unless (modifier)"
${1:${VISUAL/;//}} unless $2;
endsnippet

snippet wh "while"
while ($1)
{
	${VISUAL}$0
}
endsnippet

snippet whx "while (modifier)"
${1:${VISUAL/;//}} while $2;
endsnippet

snippet until "until"
until ($1)
{
	${VISUAL}$0
}
endsnippet

snippet xuntil "until (modifier)"
${1:${VISUAL/;//}} until $2;
endsnippet

snippet for "foreach"
foreach ${1:my $${2:i}} (${3:list})
{
	${VISUAL}$0
}
endsnippet

snippet forx "foreach (modifier)"
${1:${VISUAL/;//}} foreach $2;
endsnippet

snippet forc "for (C-style)"
for (my $${1:i} = ${2:0}; $$1 < ${3:expr}; ++$$1)
{
	${VISUAL}$0
}
endsnippet

snippet given "given"
given ($1)
{
	${VISUAL}$0
}
endsnippet

snippet when "when"
when ($1)
{
	${VISUAL}$0
}
endsnippet

snippet whenx "when (modifier)"
${1:${VISUAL/;//}} when $2;
endsnippet

snippet try "try { ... } catch { ... }"
try
{
	${VISUAL}$1
}
catch
{
	$0
};
endsnippet

### Function/Object Constructs #################################

snippet sub "Subroutine (function)" b
sub $1
{
	my ${2/([^,])+(,)?.*/(?2:\()/}${2:\$foo}${2/([^,])+(,)?.*/(?2:\))/} = ${2/([^,])+(,)?.*/(?2:@_:shift)/};
	$0
}
endsnippet

snippet new "sub new { ... }" b
sub new
{
	my $class = shift;
	my $self = bless {$1}, $class;
	return $self;
}
endsnippet

snippet method "Class method: sub foo { my $self = shift; ..." b
sub $1
{
	my ${2/[^,]*(,)?.*/(?1:\()/}\$self$2${2/[^,]*(,)?.*/(?1:\))/} = ${2/[^,]*(,)?.*/(?1:@_:shift)/};

	$0
}
endsnippet

# vim: ft=snippets ts=4
